---
title : Transaction
tags: ["JPA","java","DB"]
---



# @Transactional

> 정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애가 생겨서 작업을 완료할 수 없다면, 그 때까지 변경된 사용자의 레벨은 그대로 둘까요? 아니면 모두 초기상태로 되돌려 놓아야 할까요?

이 문제에 대한 답은,
**'작업 중간에 문제가 발생해서 작업이 중단된다면,**
**그 때까지 진행된 변경 작업도 모두 취소시켜야 한다.'**
이다.



### 트랜잭션(Transaction)

* 더 이상 나눌 수 없는 단위 작업을 말한다.(= **원자성**)
* 따라서 중간에 예외가 발생해서 작업을 완료할 수 없다면, 아예 작업이 시작되지 않은 것처럼 초기 상태로 되돌려놓아야 한다. 이것이 바로 트랜잭션이다



### DB의 트랜잭션

* DB 는 그 자체로 완벽한 트랜잭션을 지원한다.


* 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.

###### ❑ 트랜잭션 롤백(Transaction rollback)

 - 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 중간 작업에서 문제가 생겼을 때 그 전까지 완료한 작업들까지도 모두 취소시키는 것.

###### ❑ 트랜잭션 커밋(Transaction commit)

 - 여러 개의 SQL이 하나의 트랜잭션이 된 경우에, 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시키는 것.

###### ❑ 트랜잭션의 경계설정(Transaction demarcation)

 - 트랜잭션의 시작 지점과 종료 지점을 정해주는 것.
 - 종료 시점은 commit 또는 roll back을 하는 시점이 된다.
 - 트랜잭션의 경계는 하나의 connection이 만들어지고 닫히는 범위 안에 존재한다.

###### ❑ 로컬 트랜잭션(Local transaction)

 - 하나의 DB 커넥션 안에서 만들어지는 트랜잭션.



## 적용 범위

* 인터페이스를 구현한 클래스로 선언된 빈은 인터페이스 메소드에 한해서 트랜잭션이 적용됨

* 인터페이스에 붙은 @Transactional 선언은 인터페이스 내의 모든 메소드에 적용됨

* 동시에 메소드 레벨에도 @Transactional을 지정할 수 있다. 메소드 선언 > 인터페이스 선언

* 클래스의 @Transactional > 인터페이스의 @Transactional

  ​


## 적용 우선 순위

- #### @Transactional을 적용하는 우선순위는

  ####  클래스의 메소드 > 클래스> 인터페이스의 메소드 > 인터페이스


- 메소드에 @Transactional이 있으면 클래스 레벨의 @Transactional 선언보다 우선해서 적용된다.
- 클래스에 @Transactional 을 부여했을 때 트랜잭션이 적용되는 메소드는 프록시 방식과 인터페이스의 여부에 따라서 조금 달라진다. 
- 클래스의 @Transactional 은 인터페이스의 @Transactional 선언보다 우선한다. 



### @Transactional(readOnly = true)

- 트랜잭션이 읽기 전용이다. 
- 내부에서 write가 일어나면 exception이 발생한다. (내부적으로는 DB를 바라볼 때 Slave DB를 바라본다.)

### @Transactional(readOnly = false)

- 트랜잭션이 읽기/쓰기가 모두 가능하다. 

- 내부적으로는 DB를 바라볼 때 Master DB를 바라본다.

  ​

- 따라서 코딩할 때, 전체 클래스를 readOnly = true 로 잡아두고 write가 필요한 매서드 안에서만 readOnly = false 를 줘야한다.





