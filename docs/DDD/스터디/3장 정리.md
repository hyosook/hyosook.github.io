



### ※ 도메인 모델 2가지 의미

#### 1. **도메인** 자체를 표현하는 **개념적인** 모델 

- 도메인 =  (문제의 영역 =고객의 요구 사항 ) => **고객의 요구 사항 표현**
  - Rule => 고객의 요구사항
- 여러 대상이 같은 **이해**하고 **공유** 하기 위해서 의사소통 시에 사용된다. 
  - UML 로 표현할 수 있다. (클래스 다이어그램, 상태 다이어그램 표현 가능)​

#### 2. 도메인 계층의 객체 모델을 표현

* 도메인 계층 객체 지향 기법으로 구현
* 도메인 규칙(요구사항) 구현
* 핵심이 되는 로직을 구현



### ※ 도메인을 모델링 하는 작업  방법

- **요구사항** 기준으로  `구성요소` , `규칙(제약)`,`기능`  => 찾기

-  java로 구현 (표현)

- `엔티티`/`벨류`  정리
  - 주의 
    - 도메인 모델에 의미없는 SET 메서드 넣지 않기 
      - private ok => 내부사용
      - 생성자 사용해서 값을 세팅 
    - 벨류 객체에 SET을 하고 싶을때는  => 새로운 벨류 객체를 생성하는 방식 = 불변 

- 도메인 용어 

  

### ※ 네 개의 영역

* ####표현
  * **U**ser **I**nterface  &  **S**ystem **I**nterface
  * 전달 & 응답

- ####응용

  - 운전자 

    - 운전대를 잡고 `~한다`

    - call 한다 

      - 로직 수행을 **위임**한다  => 상호작용 Good

        > 응용 서비스에서 직접 로직을 넣는경우 도 있다.
        >
        > - 자주  변한다  => 캡슐화 시킨다 
        >
        >   > 캡슐화 : 숨긴다  = 내부속성 오퍼 외부로 노출x 
        >
        >   - 단점 :  class가 많아진다

- ####도메인

  - 도메인 모델을 구현
  - 핵심 로직을 구현

- ####인프라스트럭처

  - 구현 기술 

  - PSM

    

### ※ Layer Architecture

![](https://nesoy.github.io/assets/posts/20180812/1.png)

- 상위 계층에서 하위 계층으로 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.

- 응용계층이 도메인 뿐만 아니라 **Infrastructure에 의존**하기도 한다.

  - 고수준 모듈이 저수준 모듈을 사용 => 상호작용

    > 고수준 모듈  : 의미있는 단일 기능을 제공하는 모듈  => 필요 기능을 추상화 
    >
    > 저수준 모듈  : 하위 기능을 실제로 구현한 것

  - 단점
    -  테스트하기 어렵다. => **종속** 원인 
    - 구현 방식 변경 어렵다.

  - 해결 방법은 DIP를 적용하는 것이다.



###  ※ DIP(Dependency Injection Principle)

- 고수준 모듈이 저수준 모듈을 사용하면 나타나는 두가지 문제를 해결 하는 방안

- 반대로 저수준 모듈이 고수준 모듈에 의존하도록 한다 

  - 도메인 영역과 응용영역에서 정의한 인터페이스를 Infrasturcture 영역에서 구현 하는 방식으로 사용

  

- 인터페이스는 High Abstract Module 관점에서 도출해야 한다.

- 적용 방법

  - 하위 기능을 추상화 한 interface는 **고수준** 모듈 **관점**에서 **도출** 

    #### Gof의 Strategy pattern 

    - 특징
      - 바뀌는 부분은 따로 뽑아서 **캡슐화**하고 해당 기능을 **인터페이스에 위임**
        - 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다
    - 구현 방법
      1. 변하는 부분 캡슐화
      2. 인터페이스에 위임
      3. 각 객체 구현
    - 장점 
      - if 분기문을 푸는 방식중 한개
      - 객체 또는 기능이 추가/변경 되더라도 쉽고 간단하게 적용할 수 있습니
      - 코드의 중복이없이 재사용이 가능해진 것입니다
    - 단점
      - 클래스의 개수가 늘어난다

![](C:\Users\apexsoft\AppData\Roaming\Typora\typora-user-images\1551848529551.png)





###  UML

![](http://www.nextree.co.kr/content/images/2016/09/--6-----------.png)

* 의존
  * 어떤 클래스가 다른 클래스를 참조하는 것을 말합니다.
* 일반화
  * 부모와 자식 간의 상속 관계 
* 실체화
  * interface의 spec(명세, 정의)만 있는 메서드를 오버라이딩 하여 실제 기능으로 구현 하는 것을 말합니다.





### ※ 도메인 영역의 구성요소

> 도메인 영역은 도메인의 핵심 모델을 구현한다
>
> 도메인 영역의 모델은 , 도메인의 주요 개념을 표현하면서 핵심이 되는 로직을 구현한다 



* ####엔티티

  * 고유 식별자 가진다

  * 레코드 구분 가능 

  * 데이터 + **도메인 기능** 제공 (`p.56`)

    * 이때 도메인 관점에서 기능을 구현하고, 캡슐화를 해서 데이터가 임의로 변경되는것을 막는다 

      > 캡슐화 : 숨긴다  = 내부속성 오퍼 외부로 노출x 

  * **벨류 타입을 이용해서 표현 가능** (`p.56`)

* ####벨류

  * 정의
    * DTO 같은 ,  값을 담는 그릇의미  = 추상화 작업  (이름짓기 중요)
  * 사용이유
    - 두개 이상 데이터표현 OR 의미를 명확히 하기위해서
  * 불변으로 구현 (`p.58`)
    * 데이터 변경시 , 객체 자체를 완전히 교체한다

* ####애그리거트

  > * 발생 :도메인이 커질수록 , 개발한 도메인 모델도 커지면서  많은 엔티티와 벨류가 출현 =>점점 복잡해진다 
  >
  >   * 문제 :  전체 구조가 아닌, 한개의 엔티와 벨류에만 집중하게됨 
  >
  >     ​         =>   상위 수준에서 모델을 볼수 있어야 한다

  * 정의

    * **관련** 객체를 **하나**로 묶은 **군집 ** (`그림 2.17`)

  * 특징

    * 개별 객체가 아닌 , 애그리거트 간의 관계로 모데인 모델을 이해 하고 구현

      * 큰 틀에서 도메인 모델을 관리 
        * **장점** : 복잡한 모데인 모델을 관리하는데 도움

    * 군집에 속한 객체들을 관리하는  **루트엔티티**를 갖는다 (`그림 2.18`)

      * 애그리거트에 속해있는 `엔티티`,`벨류`를 이용해서 애그리거트가 구현해야 할 기능을 제공

      * 루트를 **통해**서 **간접적** 으로  애그리거트 내의 다른  `엔티티`,`벨류`에 접근

        * 내부 구현을 숨겨서 애그리거트 단위로 구현을 **캡슐화**  가능하게 한다

        *  루트(Oder)를 통하지 않고 shippingInfo를 변경할수 없다  (`p.60코드`)

          

* ####repository 

  * 도메인 모델의 영속성(`p.106`)을 처리한다 
  * 구현을 위한 도메인 모델 
  * 특징
    * 애그리거트 단위로 정의 한다
    * 루트는 애그리거트에 속한 모든 객체를 포함하고 있으므로, 결과적으로 애그리거트 단위로 저장하고 조회한다   
  * 사용 (`p.62` / `p.106`)
    * 도메인 모델을 사용해야 하는 코드는  repository 를 통해서 도메인 객체를 구한뒤
    * 도메인 객체의 기능을 실행한다 
  * 위치
    * repository 인터페이스는 도메인모델 영역에 속한다
    * 실제 구현 클래스는 인프라스트럭처 영역에 속한다 

* ####도메인 서비스

  * 특정 엔티티에 속하지 않은 도메인 로직을 제공
  * 도메인 로직이 여러 엔티티와 벨류를 필요할 경우  사용한다





### ※ Infrasturcture

- 무조건 Infrasturcture의존을 없애는 것은 좋은 것이 아니다.
  - @Transaction을 사용하는 것은 편리하다.
- DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 현명하다.
- 의존을 완전히 갖지 않도록 시도하는 것은 구현을 더 복잡하고 어렵게 만들 수 있다.



### ※ 모듈 구성

- `그림 2.22`  => 쿠팡인가요...?

- 한 패키지에 가능하면 10개 미만으로 타입 개수를 유지하려고 노력한다.

- 이 개수가 넘어가면 모듈을 분리하는 시도를 해본다.

  

### ※ DTO / VO/ MAP

![](https://imgur.com/38jF4Fz.png)

- #### DTO

  - 값을 담는 그릇 

- #### VO

  - 특징 : runtime 에서도 static해서 확인 가능
  - 단점 : vo 클래스가 많아진다

- #### MAP

  - 유연하다