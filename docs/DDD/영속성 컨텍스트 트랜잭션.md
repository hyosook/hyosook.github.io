---
title : 영속성 컨텍스트
tags : ["JPA","DB","java"]
---



## 영속성 컨텍스트

* 엔티티를 영구 저장하는 환경

* 엔티티 매니저로 엔티티를 저장하거나  조회하면 

  엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리한다

### 엔티티의 생명주기

* 비영속 (영속성 컨텍스트와 전혀 관계가 없는 상태)
* 영속 (영속성 컨텍스트에 저장된 상태)
* 준영속 (저장되었다가 분리)
* 삭제

### 영속성 컨텍스트 특징

* 영속성 컨텍스트 엔티티 = 식별자 값 (@id) 로 매핑
* 동일성 보장
* 변경 감지

### 변경 감지

* 스냅샷 : jpa는 엔티티를 영속성 컨텍스트에 보관할 때 최초 상태를 복사해서 저장해둔다
* 플러시 시점에 스탭샷과 엔티티를 비교해서 변경된 엔티티를 찾는다 
  1. 트랜잭션 커밋 = 엔티티 매니저 플러시가 호출
  2. 스냅샷으로 변경된 엔티티 찾는다
  3. 변경된 엔티티가 있으면  수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다
  4. 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다
  5. 데이터베이스의 트랜잭션을 커밋한다
* 변경 감지는 영속성 컨텍스트가 관리하는 영속 상태의 엔티티에만 적용된다.



## 트랜잭션 범위의 영속성 컨텍스트

### 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 사용한다

* 트랜잭션 범위와 영속성 컨텍스트의 생존 범위가 같다

* 트랜잭션을 시작할 때 영속성 컨텍스를 생성하고

  트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다

  ​

* 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다

  ```java
  @Transactional
  public class ProjectService {
  public void delete(int projectCode) {
       
          Project project = projectRepository.findOne(projectCode);
          project.setProjectFlag("0");
          
      }
  }
  ```

  1. `@Transactional`  선언해서 , 메소드를 호출할 때 트랜잭션을 먼저 시작한다

  2. `project`는 영속 상태 

     >  `projectRepository.findOne(projectCode)` 통해 조회한 `project`엔티티는
     >
     >  트랜잭션 범위 안에 있으므로 ,영속성 컨텍스트의 관리를 받는다

  3. `project`는 영속 상태로 변경 감지가 가능한다

  4. `@Transactional ` 선언한 메소드가 정상 종료 되면 

     >1. 트랜잭션 커밋 = 영속성 컨텍스트 종료 = 엔티티 매니저 플러시가 호출
     >2. 스냅샷으로 변경된 엔티티 찾는다
     >3. 변경된 엔티티가 있으면  수정 쿼리를 생성해서 , 쓰기 지연 sql 저장소에 보낸다
     >4. 쓰기 지연 저장소의 sql을 데이터 베이스에 보낸다
     >5. 데이터베이스의 트랜잭션을 커밋한다

     ​

     ​

     ​